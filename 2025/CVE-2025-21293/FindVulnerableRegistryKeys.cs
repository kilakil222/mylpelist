using System;
using System.Threading.Tasks;
using System.IO;
using Microsoft.Win32;
using System.Security.AccessControl;
using System.Security.Principal;


class Program
{
    static void Main(string[] args)
    {
        string outputPath = "registry_permissions.csv";
        using (StreamWriter writer = new StreamWriter(outputPath, false, System.Text.Encoding.UTF8))
        {
            writer.WriteLine("Path,SID,Principal,Permissions");

            var rootKeys = new[] { Registry.CurrentUser, Registry.LocalMachine, Registry.ClassesRoot, Registry.Users, Registry.CurrentConfig };

            Parallel.ForEach(rootKeys, rootKey =>
            {
                TraverseRegistry(rootKey, writer, rootKey.Name);
            });
        }

        Console.WriteLine($"Saved into {outputPath}");
    }

    static void TraverseRegistry(RegistryKey key, StreamWriter writer, string path)
    {
        foreach (var subkeyName in key.GetSubKeyNames())
        {
            try
            {
                var security = key.GetAccessControl();
                foreach (RegistryAccessRule rule in security.GetAccessRules(true, true, typeof(SecurityIdentifier)))
                {
                    var principal = "";
                    var sid = rule.IdentityReference.Value.ToString();

                    if (!sid.StartsWith("S-1") || path.Contains("Fusion\\References") || path.Contains("NGenService"))
                    {
                        continue;
                    }
                    try
                    {
                        principal = new SecurityIdentifier(sid).Translate(typeof(NTAccount)).Value;
                    }
                    catch
                    {
            
                    }
                    var permissions = rule.AccessControlType == AccessControlType.Allow ? "Allow" : "Deny";
                    permissions += " " + rule.RegistryRights.ToString();

                    WriteToFile(writer, path, sid, principal, permissions);
                }

                using (var subKey = key.OpenSubKey(subkeyName))
                {
                    if (subKey != null)
                    {
                        var newPath = $"{path}\\{subkeyName}";
                        TraverseRegistry(subKey, writer, newPath);
                    }
                }

            }
            catch (UnauthorizedAccessException)
            {

            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error during working with {key.Name}: {ex.Message}");
            }
        }
    }
    static void WriteToFile(StreamWriter writer, string path, string sid, string principal, string permissions)
    {
        lock (writer) 
        {
            writer.WriteLine($"\"{path}\",\"{sid}\",\"{principal}\",\"{permissions}\"");
        }
    }
}